#!/usr/bin/env python3
''' Visualize the import relationships of a python project. '''


import argparse
import os
import sys
import distutils.sysconfig as sysconfig
from pprint import pprint
from modulefinder import ModuleFinder

from libinfo import is_py2_std_lib_module, is_py3_std_lib_module


# Python 2 or 3 (int)
PY_VERSION = sys.version_info[0]


def cache(func):
    """ Wrap func with cache (doesn't work with funcs that have kwargs). """
    memo = {}

    def wrapper(*args):
        if args not in memo:
            memo[args] = func(*args)
        return memo[args]
    return wrapper


@cache
def get_std_lib_modules():
    """ Create a list of this version of python's standard library modules by
    walking the standard library directory.
    """
    std_lib = sysconfig.get_python_lib(standard_lib=True)
    std_modules = []
    for top, dirs, files in os.walk(std_lib):
        for nm in files:
            if nm != '__init__.py' and nm[-3:] == '.py':
                mod_path = os.path.join(top, nm)
                mod_name = mod_path[len(std_lib) + 1:-3].replace('/', '.')
                std_modules.append(mod_name)
    return std_modules


def is_std_lib_module(mname):
    """ Return true if the module's name is in either the list dynamically
    generated by get_std_lib_modules() or the hardcoded list retreived by
    either is_py2_std_lib_module() or is_py3_std_lib_module().
    """
    is_in_hardcoded_list = (is_py2_std_lib_module
                            if PY_VERSION == 2 else is_py3_std_lib_module)
    return (is_in_hardcoded_list(mname) or mname in get_std_lib_modules())


def abs_mod_name(module, root_dir):
    """ From a Module's absolute path, and the root directory, return a
    string with how that module would be imported from a script in the root
    directory.

    Example: abs_mod_name(Module('/path/to/mod.py'), '/path') -> 'to.mod'
    NOTE: no trailing '/' in root_dir
    """
    abs_path = os.path.abspath(module.__file__)
    rel_path = abs_path[len(root_dir):]
    path_parts = rel_path.split('/')[1:]
    path_parts[-1] = path_parts[-1][:-3]
    if path_parts[-1] == '__init__':
        del path_parts[-1]
    mod_name = '.'.join(path_parts)
    return mod_name


def get_modules_from_file(script, root_dir=None, use_sys_path=False):
    """ Use ModuleFinder.load_file() to get module imports for the given
    script.

    :param script: the script we're getting modules from
    :param root_dir: the project's root dir, if different from script's dir
    :param use_sys_path: use the system PATH when looking for module defs, this
    may be useful if you want to add stdlib modules
    :rtype: {str(module name): Module}
    """
    script = os.path.abspath(script)
    if not root_dir:
        root_dir = os.path.dirname(script)
    path = [root_dir]
    if use_sys_path:
        path.append(sys.path[:])

    finder = ModuleFinder(path)
    finder.load_file(script)
    modules = finder.modules

    if not use_sys_path:
        # Filter out standard library imports
        modules = {name: mod for name, mod in modules.items() if not
                   is_std_lib_module(name)}

    # All the module names have to be as references from the root directory
    modules = {abs_mod_name(mod, root_dir): mod for mod in
               modules.values()}

    return modules


def get_modules_in_dir(root_dir, ignore_venv=True):
    """ Walk a directory recursively and get the module imports for all .py
    files in the directory.
    """
    root_dir = os.path.abspath(root_dir)
    mods = {}

    for top, dir, files in os.walk(root_dir):
        if ignore_venv and 'venv' in top:
            continue
        for nm in files:
            if nm != '__init__.py' and nm[-3:] == '.py':
                mod_path = os.path.abspath(os.path.join(top, nm))
                mod_name = mod_path[len(root_dir) + 1:].replace('/', '.')[:-3]
                if mod_name not in mods:
                    curr_mods = get_modules_from_file(mod_path,
                                                      root_dir=root_dir)
                    for cname, cmod in curr_mods.items():
                        if cname not in mods:
                            mods[cname] = cmod
    return mods


def get_args():
    """ Parse and return command line args. """
    parser = argparse.ArgumentParser(description='Visualize imports of a given'
                                     ' python script.')
    parser.add_argument('path', type=str,
                        help='main python script/entry point for project, or'
                        ' the root directory of the project')
    parser.add_argument('-r', '--root', dest='alt_root', type=str,
                        help='alternate root, if the project root differs from'
                        ' the directory that the main script is in')
    # TODO implement ability to ignore certain modules
    # parser.add_argument('-i', '--ignore', dest='ignorefile', type=str,
                        # help='file that contains names of modules to ignore')
    return parser.parse_args()


def main():

    args = get_args()
    if args.path[-3:] == '.py':
        script = args.path
        root_dir = os.path.dirname(args.path)
        if args.alt_root:
            root_dir = args.alt_root
        modules = get_modules_from_file(script, root_dir=root_dir)
    else:
        root_dir = args.path
        modules = get_modules_in_dir(root_dir)

    pprint(modules)


if __name__ == '__main__':
    main()
